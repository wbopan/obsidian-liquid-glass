<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Liquid Glass for Obsidian</title>
    <link rel="stylesheet" href="../main.css" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-38V3HD97K9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-38V3HD97K9");
    </script>
  </head>
  <body>
    <div class="header">
      <h1>
        <a href=".."><i data-lucide="chevron-left"></i>Liquid Glass for Obsidian</a> <span>/</span> Style Settings Migration Tool
      </h1>
      <a href="https://github.com/wbopan/obsidian-liquid-glass">View Liquid Glass on GitHub</a>
    </div>
    <div class="content">
      <div class="setting-container" title="Export your existing style settings, then paste here to migrate to Liquid Glass–compatible settings.">
        <div class="setting">
          <div class="setting-sidebar">
            <div class="sidebar-section">
              <div class="sidebar-title">Community plugins</div>
              <div class="sidebar-link is-active">Style Settings</div>
            </div>
          </div>
          <div class="setting-content">
            <div class="setting-header">
              <div class="setting-search">
                <i data-lucide="search"></i>
                Search Style Settings...
              </div>
              <div class="setting-actions">
                <button>Import</button>
                <button>Export</button>
              </div>
            </div>
            <div class="setting-list">
              <div class="setting-item">
                <i data-lucide="chevron-right"></i>
                <div class="setting-item-name">Theme</div>
                <div class="setting-item-actions"><i data-lucide="rotate-ccw"></i><i data-lucide="cloud-download"></i></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Export your existing Style Settings, then paste here to migrate to Liquid Glass–compatible settings.</p>
      <div class="panels-container">
        <div class="input-panel">
          <textarea
            class="prefs-input"
            placeholder='{
  "minimal-style@@bg1@@light": "#FFFFFF",
  "minimal-style@@tabs-style": "tabs-modern"
}


Supported themes:
- Minimal
- AnuPpuccin
- Border
- Sanctum
- Things 2'
          ></textarea>
          <div class="panel-actions">
            <button class="clear-btn">Clear</button>
          </div>
          <div class="warning-container"></div>
        </div>
        <div class="output-panel">
          <textarea class="prefs-output" disabled readonly></textarea>
          <div class="panel-actions">
            <button class="copy-btn">Copy to Clipboard</button>
            <a class="download-link" href="#" download="liquid-glass-style-settings.json"><button class="download-btn">Download</button></a>
          </div>
          <div class="conflict-container"></div>
          <div class="unsupported-container"></div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        // DOM helpers
        const $ = (s, root = document) => root.querySelector(s);
        const prefsInput = $(".prefs-input");
        const newPrefsOutput = $(".prefs-output");
        const copyBtn = $(".copy-btn");
        const downloadLink = $(".download-link");
        const warningDiv = $(".warning-container");
        const conflictDiv = $(".conflict-container");
        const unsupportedDiv = $(".unsupported-container");
        const clearBtn = $(".clear-btn");

        // Small shared helpers
        const jsonCache = new Map();
        const fetchJSONOnce = async (url) => {
          if (jsonCache.has(url)) return jsonCache.get(url);
          const res = await fetch(url);
          if (!res.ok) throw new Error(`Status: ${res.status}`);
          const data = await res.json();
          jsonCache.set(url, data);
          return data;
        };
        const getMapping = () => fetchJSONOnce("mapping.json");
        const getBaselineLabels = () => fetchJSONOnce("mapping-baseline.json");
        const stripThemeSuffix = (s) => s.replace(/@@(light|dark)$/i, "");
        const isHexColor6 = (v) => typeof v === "string" && /^#[0-9A-Fa-f]{6}$/.test(v);
        const isColorCode = (v) => {
          if (typeof v !== "string") return false;
          return /^#[0-9A-Fa-f]{3,8}$/.test(v) || /^rgb\s*\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(v) || /^rgba\s*\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*(0|1|0?\.\d+)\s*\)$/.test(v) || /^hsl\s*\(\s*\d+\s*,\s*\d+%\s*,\s*\d+%\s*\)$/.test(v) || /^hsla\s*\(\s*\d+\s*,\s*\d+%\s*,\s*\d+%\s*,\s*(0|1|0?\.\d+)\s*\)$/.test(v);
        };
        const groupBy = (arr, keyFn) => arr.reduce((m, x) => ((m[keyFn(x)] ??= []).push(x), m), {});
        const setHTML = (node, html) => (node.innerHTML = html || "");

        function migratePrefs(mapping, oldPrefs) {
          const newPrefs = {},
            unsupported = [],
            conflicts = {},
            themeBases = {};

          for (const themeKey in mapping) {
            if (mapping[themeKey]?.__name) themeBases[themeKey] = mapping[themeKey].__name;
          }

          for (const k in oldPrefs) {
            if (!Object.hasOwnProperty.call(oldPrefs, k)) continue;
            const seg = k.split("@@");
            if (seg.length < 2) continue;
            const base = seg[0];
            const themeKey = Object.keys(themeBases).find((t) => base.startsWith(t));
            if (!themeKey) continue;

            const newBase = "baseline-style";
            const oldId = seg[1];
            const extra = seg.slice(2);
            const themeMapping = mapping[themeKey];
            const rules = Array.isArray(themeMapping[oldId]) ? themeMapping[oldId] : [themeMapping[oldId]];
            const val = oldPrefs[k];

            if (!rules[0]) {
              const newKey = [newBase, oldId, ...extra].join("@@");
              if (newPrefs[newKey] !== undefined) (conflicts[newKey] ??= [newPrefs[newKey]]).push(val);
              else newPrefs[newKey] = val;
              continue;
            }

            for (const rule of rules) {
              if (!rule) continue;
              if (rule.unsupported) {
                unsupported.push({
                  name: rule.name || `Key '${oldId}'`,
                  category: rule.category || "General",
                  oldValue: val,
                  theme: themeKey,
                });
                continue;
              }

              let newVal = val;
              let newKey = rule.newId || oldId;

              if (rule.valueMapping) {
                const vRule = rule.valueMapping[val];
                if (vRule === undefined) {
                  if (rule.valueMapping.__fallback !== undefined) newVal = rule.valueMapping.__fallback;
                  else {
                    unsupported.push({
                      name: `Value '${val}' for setting '${oldId}'`,
                      category: rule.category || "Unsupported Options",
                      theme: themeKey,
                    });
                    continue;
                  }
                } else if (vRule?.unsupported) {
                  unsupported.push({
                    name: vRule.name || `Option '${val}'`,
                    category: vRule.category || "General",
                    theme: themeKey,
                  });
                  continue;
                } else newVal = vRule;
              }

              const assignVal = (nk) => {
                const finalKey = [newBase, nk, ...extra].join("@@");
                if (newPrefs[finalKey] !== undefined) (conflicts[finalKey] ??= [newPrefs[finalKey]]).push(newVal);
                else newPrefs[finalKey] = newVal;
              };

              Array.isArray(newKey) ? newKey.forEach(assignVal) : assignVal(newKey);
            }
          }

          // Collapse identical conflict values and dedupe
          for (const key in conflicts) {
            const vals = conflicts[key];
            if (vals.every((v) => v === vals[0])) {
              newPrefs[key] = vals[0];
              delete conflicts[key];
            } else {
              conflicts[key] = Array.from(new Set(vals));
            }
          }

          return { newPrefs, unsupported, themeBases, conflicts };
        }

        async function renderWarnings(prefs) {
          const labels = (await getBaselineLabels().catch(() => ({}))) || {};
          const keysWithNumbers = [];
          for (const key in prefs) {
            const val = prefs[key];
            if (typeof val === "string" && /\d/.test(val) && !isColorCode(val)) keysWithNumbers.push(key);
          }
          if (!keysWithNumbers.length) return setHTML(warningDiv, "");

          let html = `<h2 class="warning-title">Note</h2>`;
          html += `<div class="warning-content"><div class="warning-description">Following settings might not work correctly, please double check after importing.</div>`;
          html += `<ul class="warning-list">`;
          for (const key of keysWithNumbers) {
            const labelKey = stripThemeSuffix(key.replace(/^baseline-style@@/, ""));
            const displayKey = labels[labelKey] || labelKey;
            html += `<li class="warning-item">${displayKey}</li>`;
          }
          html += `</ul></div>`;
          setHTML(warningDiv, html);
        }

        let conflictListenerSetup = false;
        async function renderConflicts(conflicts, prefs) {
          const labels = (await getBaselineLabels().catch(() => ({}))) || {};
          if (!Object.keys(conflicts).length) return setHTML(conflictDiv, "");

          let html = `<h2>Conflicts</h2>`;
          for (const key in conflicts) {
            const strippedKey = key.replace(/^baseline-style@@/, "");
            const labelKey = stripThemeSuffix(strippedKey);
            const themeType = strippedKey.includes("@@light") ? "Light Theme" : strippedKey.includes("@@dark") ? "Dark Theme" : "";
            const displayKey = labels[labelKey] || labelKey;
            html += `<div class="conflict-item"><div class="conflict-key">${displayKey}</div>`;
            if (themeType) html += `<div class="conflict-theme">${themeType}</div>`;
            html += `<div class="conflict-actions">`;
            conflicts[key].forEach((val, idx) => {
              const valueLabel = labels[val] || val;
              html += `<label data-conflict-key="${key}" data-conflict-value="${val}" class="conflict-label${idx === 0 ? " selected" : ""}">`;
              html += `${valueLabel}`;
              if (isHexColor6(val)) html += `<span class="color-preview" style="background-color: ${val};"></span>`;
              html += `</label>`;
            });
            html += `</div></div>`;
          }
          setHTML(conflictDiv, html);

          // Event delegation for conflict selection (set up once)
          if (!conflictListenerSetup) {
            conflictDiv.addEventListener("click", (e) => {
              const label = e.target.closest?.(".conflict-label");
              if (!label || !conflictDiv.contains(label)) return;
              const key = label.dataset.conflictKey;
              conflictDiv.querySelectorAll(`[data-conflict-key='${key}']`).forEach((l) => l.classList.remove("selected"));
              label.classList.add("selected");

              const selectedPrefs = { ...prefs };
              conflictDiv.querySelectorAll(".conflict-label.selected").forEach((sel) => {
                const k = sel.dataset.conflictKey;
                let v = sel.dataset.conflictValue;
                if (v === "true") v = true;
                else if (v === "false") v = false;
                selectedPrefs[k] = v;
              });
              updateOutput(selectedPrefs);
            });
            conflictListenerSetup = true;
          }
        }

        function renderUnsupported(unsupported, themeBases) {
          if (!unsupported.length) return setHTML(unsupportedDiv, "");
          let html = `<h2>Unsupported style settings</h2>`;
          const byTheme = groupBy(unsupported, (i) => i.theme || "unknown");
          for (const theme in byTheme) {
            const readable = themeBases?.[theme] || theme;
            html += `<div class="unsupported-theme"><div class="unsupported-theme-name">${readable}</div>`;
            const byCat = groupBy(byTheme[theme], (i) => i.category || "General");
            for (const cat in byCat) {
              const seen = new Set();
              html += `<div class="unsupported-category"><div class="unsupported-category-name">${cat}</div><ul class="unsupported-list">`;
              for (const item of byCat[cat]) {
                const stripped = item.name.replace(/@@(light|dark)$/i, "");
                if (seen.has(stripped)) continue;
                seen.add(stripped);
                html += `<li class="unsupported-item">${item.name}</li>`;
              }
              html += `</ul></div>`;
            }
            html += `</div>`;
          }
          setHTML(unsupportedDiv, html);
        }

        function updateOutput(prefs) {
          const str = Object.keys(prefs).length ? JSON.stringify(prefs, null, 2) : "";
          newPrefsOutput.value = str;
          downloadLink.href = "data:text/json;charset=utf-8," + encodeURIComponent(str);
        }

        async function showResults(prefs, unsupported, themeBases, conflicts) {
          updateOutput(prefs);
          renderUnsupported(unsupported, themeBases);
          await renderWarnings(prefs);
          await renderConflicts(conflicts, prefs);
        }

        // UI actions
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(newPrefsOutput.value).then(() => {
            copyBtn.textContent = "Copied!";
            setTimeout(() => (copyBtn.textContent = "Copy to Clipboard"), 2000);
          });
        };
        clearBtn.onclick = () => {
          prefsInput.value = "";
          showResults({}, [], {}, {});
        };

        // Input parsing + migration
        let lastInput = "";
        prefsInput.addEventListener("input", () => {
          const val = prefsInput.value;
          if (val === lastInput) return;
          lastInput = val;
          if (!val.trim()) return showResults({}, [], {}, {});

          getMapping()
            .then((mapping) => {
              let oldPrefs;
              try {
                oldPrefs = JSON.parse(val);
              } catch (e) {
                showResults({}, [], {}, {});
                newPrefsOutput.value = `Error parsing preferences: ${e.message}`;
                return;
              }
              const { newPrefs, unsupported, themeBases, conflicts } = migratePrefs(mapping, oldPrefs);
              showResults(newPrefs, unsupported, themeBases, conflicts);
            })
            .catch((e) => {
              showResults({}, [], {}, {});
              newPrefsOutput.value = `Error loading mapping file: ${e.message || e}`;
            });
        });

        // Initial render
        showResults({}, [], {}, {});
      })();
    </script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
      lucide.createIcons();
    </script>
  </body>
</html>
